<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Farseerfc Blog</title><link href="http://farseerfc.github.com" rel="alternate"></link><link href="http://farseerfc.github.com/feeds/all.atom.xml" rel="self"></link><id>http://farseerfc.github.com</id><updated>2012-02-25T06:17:53Z</updated><entry><title>Try Pelican</title><link href="http://farseerfc.github.com/try-pelican.html" rel="alternate"></link><updated>2012-02-25T06:17:53Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/try-pelican.html</id><summary type="html">&lt;p&gt;This is my first blog with Pelican!&lt;/p&gt;
</summary></entry><entry><title>&lt;a class="reference external" href="http://www.cnbeta.com/articles/156747.ht"&gt;http://www.cnbeta.com/articles/156747.ht&lt;/a&gt;</title><link href="http://farseerfc.github.com/a-classreference-external-hrefhttpwwwcnbetacomarticles156747hthttpwwwcnbetacomarticles156747hta.html" rel="alternate"></link><updated>2011-09-30T01:38:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/a-classreference-external-hrefhttpwwwcnbetacomarticles156747hthttpwwwcnbetacomarticles156747hta.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://www.cnbeta.com/articles/156747.htm"&gt;http://www.cnbeta.com/articles/156747.htm&lt;/a&gt;
·交通大学のお宅が作ったゲーム|image0|&lt;/p&gt;
</summary><category term="Uncategorized"></category></entry><entry><title>关于我的Blogs</title><link href="http://farseerfc.github.com/blogs.html" rel="alternate"></link><updated>2011-09-27T02:35:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/blogs.html</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;.\wp\blogs.rst&lt;/tt&gt;, line 2)&lt;/p&gt;
&lt;p&gt;Title underline too short.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
关于我的Blogs
#########
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;很久没有写过blog或者之类的东西了。这边一直荒废着。
由于国内被墙的原因，另一个wordpress： &lt;a class="reference external" href="http://fchome.sinaapp.com/"&gt;http://fchome.sinaapp.com/&lt;/a&gt;
应该会同步更新这里的内容。 抽空写点什么吧。|image0|&lt;/p&gt;
</summary><category term="life"></category></entry><entry><title>Hello world!</title><link href="http://farseerfc.github.com/hello-world.html" rel="alternate"></link><updated>2010-09-03T14:42:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/hello-world.html</id><summary type="html">&lt;p&gt;Welcome to WordPress.com. This is your first post. Edit or delete it and
start blogging! I will post some of my wiki pages here.|image0|&lt;/p&gt;
</summary><category term="Uncategorized"></category></entry><entry><title>[zz]“西厢计划”原理小解</title><link href="http://farseerfc.github.com/zz.html" rel="alternate"></link><updated>2010-03-17T01:40:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/zz.html</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;.\wp\zz.rst&lt;/tt&gt;, line 2)&lt;/p&gt;
&lt;p&gt;Title underline too short.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[zz]“西厢计划”原理小解
##############
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;好神奇的想法，先存着，以后慢慢研究 原文： ht
tp://blog.youxu.info/2010/03/14/west- chamber/
待月西厢下，迎风户半开。隔墙花影动，疑是玉人来。
最近推上最流行的一个关键词是”西厢计划”,
这个计划名字取得很浪漫，客户端叫做张生，对，就是西厢记里面那个翻墙去见崔莺莺小姐的张生；显然，服务器端必然叫做崔莺莺。客户端的张生是最重要的部件，可以不依赖于服务端工作。因为西厢计划的作者只是简要的介绍了一下原理，其他报道又语焉不详，我当时就觉得很好奇，花了昨天一个晚上详细读了一下源代码，终于知道怎么回事了，觉得原理非常漂亮，所以写篇文章介绍总结一下。
先说大方向。大家都知道，连接被重置的本质，是因为收到了破坏连接的一个 TCP
Reset 包。以前剑桥大学有人实验过，客户端和服务器都忽略 Reset,
则通信可以不受影响。但是这个方法其实只有理论价值，因为绝大多数服务器都不可能忽略
Reset 的 (比如 Linux, 需要 root 权限配置iptables, 而且这本身也把正常的
Reset 给忽略了)。只要服务器不忽略 Reset,
客户端再怎么弄都没用，因为服务器会停止发送数据，Reset
这条连接。所以，很多报道说西厢计划是忽略 Reset,
我从源代码来看应该不是这样。在我看来，西厢计划是利用了墙的一个可能的弱点–墙只在连接发起的时候把一个
TCP
连接加入监听序列，如果墙认为这个连接终止了，就会从监听序列中去掉这条记录，这样，这条连接上后续的包就不会被监听。西厢计划就是让墙“认为”这个连接终止的一个绝妙的方法。只要墙认为这个连接两端都是死老虎，墙就不会触发关键词检测，其后所有的数据，都不存在连接被重置的问题了。
如何让一个连接置之死地而后生，就是西厢计划那帮黑客神奇的地方了。这也不是一日之功。
首先，这帮牛人发现，墙的是一个入侵检测系统，把含有关键字的包当成一种“入侵”来对待。采取这种设计有很多好处，但缺点是入侵检测系统可能具有的问题，墙都可能有。西厢计划主页上那篇著名的论文就是讲这些七七八八的漏洞的。可以说处理这些七七八八的漏洞是非常困难的，迫使墙的设计者“拆东墙，补西墙”。这样补来补去，外表看起来好像很牛逼的墙，其实有很多本质上无法简单修补的漏洞，其中有一个致命的，就是
TCP 连接状态的判定问题。
出于入侵检测系统这种设计的局限，墙没有，也没办法准确判定一条 TCP
连接的状态，而只是根据两边收到的数据来“推测”连接的状态。而所有的关键词检测功能，都是基于“连接还活着”的这个推测的结果的。因为墙的规则是在连接发起的时候开始对这条连接的检测，在连接终止的时候停止对这条连接的检测，所以，一旦对连接的状态推测错误，把还活着的连接当成已经关闭的连接，墙就会放弃对这条连接上随后所有的包的检测，他们都会都透明的穿过墙的入侵检测。
上面只是想法，具体到 TCP
协议实现这一层，就要只迷惑墙，还不能触及我要通信的服务器。最理想的情况下，在任何有效通信之前，就能让墙出现错误判断，这些，就需要对
TCP 协议有深刻理解了。西厢计划的那帮黑客，居然真的去读 TCP 几百页的
RFC，还居然就发现了方法（这里我假设读者都知道 TCP
的三次握手过程和序列号每次加一的规则）。
我们都知道，三次握手的时候，在收到服务器的 SYN/ACK 的时候，客户端如果发送
ACK 并且序列号+1 就算建立连接了，但是客户端如果发送一个序列号没 +1
[...]|image0|&lt;/p&gt;
</summary><category term="计算机与 Internet"></category></entry><entry><title>AP news</title><link href="http://farseerfc.github.com/ap-news.html" rel="alternate"></link><updated>2007-09-22T12:50:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/ap-news.html</id><summary type="html">&lt;p&gt;&lt;a class="reference external" href="http://bbs.putclub.com/index.php?showtopic=109260"&gt;http://bbs.putclub.com/index.php?showtopic=109260&lt;/a&gt; &lt;img alt="image0" src="http://stats.wordpress.com/b.gif?host=farseerfc.wordpress.com&amp;amp;blog=15617405&amp;amp;post=4&amp;amp;subd=farseerfc&amp;amp;ref=&amp;amp;feed=1" /&gt;&lt;/p&gt;
</summary><category term="Uncategorized"></category></entry><entry><title>由记忆棒误差故障引发的关于面向对象设计的九点思考</title><link href="http://farseerfc.github.com/.html" rel="alternate"></link><updated>2007-09-20T06:38:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/.html</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;.\wp\.rst&lt;/tt&gt;, line 2)&lt;/p&gt;
&lt;p&gt;Title underline too short.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
由记忆棒误差故障引发的关于面向对象设计的九点思考
########################
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;故障描述:MMC Memory Stick Duo记忆棒未经Adapter适配器，直接插入SD
Reader，致使MMC卡入SD Reader中。
栈展开：某日下午，无课。忙于数分作业，想查询用手机拍摄的板书照片。取出手机中的MMC。未经装配Adapter，直接插入SD
Reader。(A runtime exception was
thrown.)尝试翻转笔记本机身，倒出MMC，未果。(rethrow)尝试用手指甲取出，未果。(rethrow)考虑到有“推入反弹”机制，尝试将MMC推入更深，反弹机制由于类型不匹配而失效，未果。(rethrow)(The
exception spread across the border of the
model.)电脑维修技师接手(catch)技师未能发现问题所在，由我解说原委。(Because
the exception lose the information, RTTI was asked to recall the
information)技师发现问题，尝试用镊子镊出MMC，未果。技师开解机箱(expose the
data structure)技师制作钩子，勾出MMC(hooker link to the
structure)取出MMC，故障解除
故障总结1.接收到没有完全了解、或没有适当工具解决的exception时，不要尝试用不成熟的技术解决，应尽快寻求能解决它的代码。否则，被反复rethrow的exception，尤其是通过模块边界的exception，有可能由subclass退化为superclass，并因此而丧失一些信息。尽量不要让exception丢失信息，必要时，通过RTTI机制寻回信息。
2.超负荷运转，多线程执行，这种种复杂性都有可能导致错误，应避免。无论你有多么信任你的代码或能力。
3.在设计class的interface时，相匹配的interface应该满足is-a的关系。因此，任何能插入SD
Reader的object，即任何实现了SD interface的object，都应该is-a SD
card。这次故障中，interface接受了MMC，但MMC不是SD。即使这种情况下throw an
exception，都不能使事态缓和。能提供compile-time
error时，尽量让错误以compile-time
error的形式展现，并在事先解决。类型匹配问题是应该能在事先解决的问题。
4.Design patterns中的Adapter
pattern应该只是迫不得已情况之下的解决方案。只有当你无权改变现状时，才能使用Adapter。如果能改变现状，应该改变设计以符合interface。
5.因为上条，所有相似功能的对象应具有相同的interface，不同的interface是本次故障的根源所在。
6.特殊情况下，破坏封装机制并expose the data
structure是必要的，应该有方法支持这种做法。C的指针和C#的Reflection技术都以不同的方式支持这种做法。其他的一些语言机制，比如serializing(序列化)或streaming(流化)，也可以以某种方式间接支持这一做法。当然，机制还应避免这种做法被滥用。
7.相反功能具有相同操作的设计，容易造成使用的混乱，应适当避免。比如SD
Reader的推入反弹设计，即插入和弹出使用同一个向里推的操作的设计。同样的设计还包括，C++中的setNewHandle使用同一个函数，同时设置和返回handle。以及有些书中提倡的，使用同名函数重载的方式，实现setter/getter的设计。
8.特殊工具(hooker)对于解决特定问题，通常比手工解决有效。不要嫌麻烦而不愿意构造特殊工具。
9.栈语义，即FILO顺序，总在不知不觉中影响我们。违反了FILO顺序的操作极易造成混乱。本故障发生时正确的处理顺序为：装配Adapter
插入SD Reader 读取数据 停用设备 拔出SD
Reader拆解Adapter本次故障的原因就是违反了FILO顺序，违反了栈语义。
&lt;img alt="image0" src="http://stats.wordpress.com/b.gif?host=farseerfc.wordpress.com&amp;amp;blog=15617405&amp;amp;post=5&amp;amp;subd=farseerfc&amp;amp;ref=&amp;amp;feed=1" /&gt;&lt;/p&gt;
</summary><category term="计算机与 Internet"></category></entry><entry><title>Program Development in Java 1 Introduction</title><link href="http://farseerfc.github.com/program-development-in-java-1-introduction.html" rel="alternate"></link><updated>2007-09-16T05:29:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/program-development-in-java-1-introduction.html</id><summary type="html">&lt;p&gt;1 简介 Introduction
本书将发展出一套构建软件系统的方法。我们的目标是帮助程序员构建高质量程序——可靠，高效，尽量容易理解、修改和维护的程序。
一个很小的不超过几百行代码构建的程序，可以被实现成单独的一个整体单元(monolithic
unit)。然而随着程序增大，这样一个整体的结构不再合理，因为代码变得难以理解。因此，程序必须被分解成大量小块独立程序，叫做模块(module)，它们一起提供需要的功能。我们将专注于这个分解的过程：怎样将大型程序问题分解成小问题，什么样的模块在这一过程中最有用，以及怎样的技术能更好的将模块组合起来解决原始的问题。
随着程序由于种种原因增大，适当地分解工作变得越来越重要。首先，大型程序的构建工作必须涉及许多人。如果只有很少的一部分人在为程序工作，他们很自然的相互频繁沟通。这种交流减少了对彼此正在开发的代码的误解，并且它降低了误解导致的后果的严重性。如果许多人在一个计划上工作，频繁的交流因为太消耗时间而变得不可能。因此，整个程序必须分解成小块，让每个人都可以用最小的沟通独立地工作。
当一个程序被分发到客户时，它的有用时期（作为产品的时期）才开始。然而这时对于程序的工作仍没有结束。代码很可能包含需要注意的残留错误，并且程序经常要求被修改，以提升程序的服务能力，或提供更好地符合客户需求的服务。对程序的修改和维护很可能占用整个工程的大部分。
为了修改和维护，推倒重来重新设计整个程序通常是不现实的。因此，必须在已有的结构上翻新修改，所以结构适应于改变是很重要的。尤其是每部分程序必须相互独立，这样对一部分程序的改变才不至于需要改变程序的每一部分。
最后，大多数程序有很长的服役期。程序员经常需要处理那些他们很久以前编写的程序。并且，实际上很有可能在一个工程的服役期中发生人事调换，这样程序的修改和维护通常是原始实现者之外的人做的。所有这些因素要求程序以容易理解的方式编写。
在我们将在书中描述的方法中，基于有用抽象的认知，程序将以分解问题的方式开发。分解(decomposition)和抽象(abstraction)，这两个书中的关键概念，将是我们的下一个主题。
1.1 分解和抽象 Decomposition and Abstraction
最基本的处理大型问题的原则是明确的——必须“分而治之”。不幸的是，仅仅决定要遵循古训，我们离解决手头的问题还有很长的一段路要走。准确地说，选择怎样分解问题才是最重要的。
分解程序的目标是创造那些自己是小程序的模块，互相之间通过良好定义的简单方式相互耦合。如果达到了这个目标，不同的人可以独立的在不同的模块上工作，互相之间不需要太多交流，并且模块会一起协同工作。另外，在程序的修改和维护过程中，有可能修改一个模块而不影响到其它的模块。
当我们分解问题时，我们用这样的方法把它划分为子问题： n
每一个子问题处在同样的细节层面。 n 每一个子问题可以被独立解决。 n
组合所有子问题的解决方案可以解决原始问题。 排序算法中的归并排序(merge
sort)是分而治之解决问题的典型示例。它把排序一组任意数量的数据的问题分解为排序两组较少的数据，然后将它们归并为原始数量的已排序数据。
分解是一种历史悠久并且有用的技术，在许多领域中发挥着作用。从Babbage[1]时代以来，人们就已经意识到象宏(macro)和子程序(subroutine)这样的分解设施对程序员很有帮助。然而同样重要的是认识到，分解并不是万能的，如果不能正确使用，它有可能造成危害。而且，大型或者没有很好领悟的问题很难适当的分解。最通常的问题是构建了单独的组建解决了描述的子问题，但是不能将他们组合起来解决原始的问题。这也是为什么系统集成通常很难实现。
举个例子，想象让一群作家聚在一起编写剧本，给每个人一份角色名单和情节提纲，然后让他们分别撰写一位角色的台词。作家们可能出色的完成了他们各自的任务，但是他们的成果结合起来不可能成为一个出色的剧本。它很可能完全缺乏一致性或逻辑性。如果原本的任务已经被以一种起反作用的方式分割，那么单独来看可行的方案完全不能适当地组合在一起。
通过改变考虑细节的层面，抽象可以有效地实施分解。当我们从一个问题抽象时，我们可以忽略一些细节，把原始问题转换为一个更简单的问题。举个例子，我们可能将写剧目的问题抽象成它应该有几幕，或者它的情节将是什么，或者是每一段独立的对话的大意（而不是用词）是什么。在这一步骤做完之后，原来的问题（写所有的对话）仍然存在，但它已经被极大地简化了——可能甚至已经可以让别人或者甚至几个人来接手写它了。（Alexandra
Dumas père大仲马就是这样“勾兑”出他的小说的。）
在程序设计过程中抽象以及分解的方法是典型的：分解用来将软件拆散成小的组建，可以将它们组合起来解决原始的问题；抽象则帮助怎样正确地选择组建。我们在这两个过程中切换，直到我们已经把原始问题降低到一系列我们知道如何去解决的问题。
1.2 抽象 Abstraction
一个abstraction的过程可以看作是一个多对一映射的运用。它允许我们忽略掉一些信息，结果是我们可以将不同的东西当作同样的对待。我们这样做是希望，通过把相关的属性和无关的属性区分开来，可以简化我们的分析工作。然而记住这一点很重要，相关性通常由环境决定。在小学的课堂学习环境中我们学会将以及5+3的概念抽象为我们用数字8来表达的概念。在多年之后的学习中，通常是一个讨厌的环境下，我们学到在许多计算机上这样的抽象会把我们卷进一大堆麻烦。
举个例子，考虑在图示1.1中显示的结构。在其中的主要概念是“哺乳动物”。所有的哺乳动物共享一些特点，比如说雌性产奶。在这一层的抽象中，我们关注这些共同的特点，并忽略那些不同种类的哺乳动物间的区别。
在更低的抽象层次中，我们可能尤其关注于哺乳动物实例。然而甚至此时我们也可以不考虑个体或种群，而是一组相关的种群。在这一层次，我们可以按照灵长类和啮齿类来分类。再一次，我们关注于共同的特点，而不是人类和黑猩猩这样的差异。这种差异在更低的一层抽象中起作用。
示例1.1 一个抽象层次
示例1.1中的抽象层次来自于动物学领域，但是它同样可能出现在一个动物学应用的程序中。一个更明确的面向计算机的示例是在很多程序中发挥作用的“文件”的概念。文件是抽象自原始存储(raw
storage)概念，并且提供长期在线存储的命名设施。操作系统对于文件的理解各有不同；举个例子，文件名的结构在每个系统上各不相同，同样文件被存储在后备存储设备上的形式也不相同。
在本书中，我们对抽象感兴趣，是因为它普遍使用在程序中。现代这一领域中最明显的发展是高级语言。通过直接处理高级语言的结构，而不是和（高级语言结构转换成的）机器指令序列打交道，程序员的工作得到了显著地简化。
然而在近几年，程序员变得对高级程序语言通常达到的抽象层次表现出不满。举个例子，考虑示例1.2中的程序片断。在被语言定义的抽象层面，这些片断很明显是不同的：如果在数组a中出现了e，那么第一段记录第一次出现的序号，而第二段记录最后一次出现的序号。如果没有出现e，一个会设置i为a.length，另一个会设置为-1。然而两端代码达成了同一个目标也不是不可能的：如果a中没有出现e，那么将found设为false，否则设为true并且z被设为a中出现的e的序号。如果这正是我们所需要的，这从程序段本身来看并不明显。
示例1.2 两段程序片断 //正向搜索 found=false; for (int i = 0; i
[...]|image0|&lt;/p&gt;
</summary><category term="计算机与 Internet"></category></entry><entry><title>Program Development in Java Preface</title><link href="http://farseerfc.github.com/program-development-in-java-preface.html" rel="alternate"></link><updated>2007-09-16T05:26:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/program-development-in-java-preface.html</id><summary type="html">&lt;p&gt;程序开发原理 ——抽象、规格与面向对象设计 Barbara Liskov 、John Guttag 著
杨嘉晨 等译 关于翻译风格：
多年来阅读计算机类的著作及译作，感觉总体的困难在于一大堆没有标准译名的技术术语。由于通行于工业界和学术界的还是英文原名和术语，我决定保留大量的英文术语。这样的翻译风格借鉴于台湾著名的译者和作者侯捷先生。对于译与不译的权衡，主要考虑阅读的流畅，以及读者的理解能力，或许难免带有一些主观色彩。
前言 Preface
构建产品级质量的程序——可以在很长一段时间内使用的程序——众所周知是极其困难的。本书的目标就是改善程序员解决这项任务的效率。我希望读者在阅读本书之后成为一名好程序员。我相信本书的成功在于改善编程技巧，因为我的学生告诉我这已经发生在他们身上。
怎么才算是一名好程序员？是产生整个程序产品的效率。关键是要在每一阶段减少浪费掉的努力。解决的方法包括：在开始编写代码之前就仔细考虑你的实现方案，通过未雨绸缪的方法来编写代码，使用严格的测试在早期发现错误，以及仔细注意模块化编程，这样当错误出现时，只需要改动极少数代码就可以修正整个程序。本书涉及所有这些领域的技术。
模块化编程(Modularity)是编写好程序的关键。把程序分解成许多小模块，每一个模块通过良好定义的狭窄接口和别的模块交互作用(interact)。有了模块化，可以修正一部分程序中的错误而不考虑程序的其他部分，而且可以仅仅理解一部分程序而不必理解整个程序。没有模块化，程序是一大堆有着错综复杂的相互关系的部分的拼凑。很难去领悟和修改这样一个程序，同样也很难让它正常工作。
因此本书的重点在于创建模块化的程序：怎样把程序组织成一系列精心挑选的模块。本书认为模块化就是抽象(abstraction)。每一个模块意味着一个抽象，比如说指引一系列文档中的关键字的目录，或者在文档中使用目录来查找匹配某个问题的文档的过程。着重强调面向对象编程思想——在程序中使用数据抽象和对象的思想。
这本书使用Java作为它的编程示例的语言。我们没有假定读者已经熟悉Java。尽管可能没什么价值，但是本书中的思想是语言无关的，并且可以在任何语言的编程中使用。
怎样使用这本书？ How Can the Book Be Used
本书《程序开发原理》有两种使用方法。其一是作为课本教材，讲述如何用面向对象的方法来设计和实现复杂系统；其二是编程专家使用，帮助他们改善编程技能，增进他们的关于模块化和Object-Oriented(面向对象)设计的知识。
作为教材使用时，本书一般作为第二或第三门程序设计课程。我们已经在MIT使用本书很多年，给大一大二的本科生教授第二门编程课。在这一阶段，学生们已经知道怎样编写小程序。课程在两方面利用这一点：让学生更仔细地思考小程序，以及教他们如何利用小程序作为组件构建大型程序。这本书也可以在专业（如软件工程）后期教学中使用。
建立在本书基础上的课程适合于所有计算机科学专业。尽管许多学生可能永远不会成为真正的大型程序的设计师，他们可以在开发部门工作，在那儿他们负责设计和实现能与整个结构耦合的子系统。模块化设计的子系统是这种任务中心，这对那些从事大型程序设计任务的人来说也同样重要。
这本书讲什么？What Is This Book About
通观全篇三分之二的书致力于讨论在构建独立的程序模块时产生的问题，剩下的部分讨论怎样运用这些模块构建大型程序。
程序模块Program Modules 这一部分的书集中讨论抽象机制(abstraction
mechanism)。它讨论procedure(子程序)和exception(异常)，数据抽象，遍历(iteration)抽象，数据抽象系列(family)以及多态(polymorphic)抽象。
在对抽象的讨论中，三个步骤是重要的。首先是决定被抽象的东西到底是什么：它提供给它的用户哪些行为。创造抽象是设计的关键，因此本书讨论如何在众多选择中挑选，以及怎样才能创造出好的抽象。
第二步是通过为一个抽象制定一个规格(specification)来获取它的意义。如果没有一些描述，一个抽象就会含糊不清，而变得没有使用价值。specification则提供了需要的描述。本书定义了一种specification的格式，讨论了一份好的specification应有的属性，并且提供了许多示例。
第三步是实现抽象。本书讨论怎样设计一份实现，以及在简洁性和执行性能之间怎样权衡利弊。书中强调封装(encapsulation)的重要性以及在一份实现中履行规格中定义的行为的重要性。书中同样提供一些技术——尤其是不变式断言(representation
invariant)和抽象函数(abstraction
function)——来帮助读者理解代码和它的原因。不变式断言和抽象函数都实现到尽可能的程度，这对于除错和调试很有用。
关于类型层次(type
hierarchy)的材料注重讨论使用它作为抽象的技术——一种把相关联的一组数据抽象归入同一系列的技术。这里很重要的一点是，是否应当将一个类型作为另一个类型的子类。本书定义了替换原则——通过比较子类和父类的specification，来决定是否建立子类关系的方法[1]。
本书同样涉及除错和调试。书中讨论怎样得到足够数量的测试情况，来准备通过黑箱和白箱测试，它同样强调了复查(regression)测试的重要性。
编写大型程序 Programming in the Large
本书的其后部分讲解怎样用模块化的方法设计和实现大型程序。它建立在前文有关abstraction和specification的材料的基础之上。
编写大型程序涵盖四个主要议题。首先讲解需求分析——怎样才能领悟程序中需要什么。本书讨论怎样实施需求分析，也讨论书写产生的需求规格的方式，通过使用一种描述程序的抽象阶段的数据模型。使用这种模型将产生一份更为正式的specification，同时它也使需求检查更加严格，这样可以更好的领悟需求。
编写大型程序的第二项议题是程序设计，这通常是一个循序渐进的过程。设计过程围绕构建有用的抽象来组织，这些抽象作为整个程序之中理想的构建组建。这些抽象在设计时被仔细的编写规格，这样当程序实现时，那些实现抽象的模块可以独立地开发。这种设计使用设计笔记编写文档，包括描述整个程序结构的模块间依赖性的图示。
第三项议题是实现和测试。本书讨论了前置设计分析对于实现的必要性，以及怎样进行设计复审。它同样讨论了设计和实现的顺序。这一部分比较了自顶而下与自底而上的组织方式，讨论如何使用驱动程序和占位程序[2](stub)，并且强调了制定一个事先的顺序策略的必要性，以满足开发组织和客户的需求。
[...]|image0|&lt;/p&gt;
</summary><category term="计算机与 Internet"></category></entry><entry><title>C++ Tricks 3.2 标号、goto，以及switch的实现</title><link href="http://farseerfc.github.com/c-tricks-32-gotoswitch.html" rel="alternate"></link><updated>2007-09-16T05:08:00Z</updated><author><name>Jiachen Yang</name></author><id>http://farseerfc.github.com/c-tricks-32-gotoswitch.html</id><summary type="html">&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;.\wp\c-tricks-32-gotoswitch.rst&lt;/tt&gt;, line 2)&lt;/p&gt;
&lt;p&gt;Title underline too short.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
C++ Tricks 3.2 标号、goto，以及switch的实现
##################################
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;3.2 标号、goto，以及switch的实现
goto语句及标号(label)是最古老的C语言特性，也是最早被人们抛弃的语言特性之一。像汇编语言中的jmp指令一样，goto语句可以跳转到同一函数体中任何标号位置：
void f() {int i=0; Loop: //A label ++i; if(i&amp;lt;10)goto Loop; //Jump to the
label } 在原始而和谐的早期Fortran和Basic时代，我们没有if then
else，没有for和while，甚至没有函数的概念，一切控制结构都靠goto(带条件的或无条件的)构件。软件工程师将这样的代码称作“意大利面条”代码。实践证明这样的代码极容易造成混乱。
自从证明了结构化的程序可以做意大利面条做到的任何事情，人们就开始不遗余力地推广结构化设计思想，将goto像猛兽一般囚禁在牢笼，标号也因此消失。
标号唯一散发余热的地方，是在switch中控制分支流程。
很多人不甚了解switch存在的意义，认为它只是大型嵌套if then
else结构的缩略形式，并且比if语句多了很多“不合理”的限制。如果你了解到switch在编译器内部的实现机制，就不难理解强加在switch之上的诸多限制，比如case后只能跟一个编译期整型常量，比如用break结束每一个case。首先看一个switch实例：
switch (shape.getAngle()) { case 3: cout&amp;lt;&amp;lt;”Triangle”;break; case 4:
cout&amp;lt;&amp;lt;”Square”;break; case 0:case1: cout&amp;lt;&amp;lt;”Not a sharp!”;break; default:
cout&amp;lt;&amp;lt;”Polygon”; } 任何程序员都可以写出与之对应的if结构： int i=
getAngle(shape); if (i==3) cout&amp;lt;&amp;lt;”Triangle”; else if(i==4)
cout&amp;lt;&amp;lt;”Square”; else if(i==0||i==1) [...]|image0|&lt;/p&gt;
</summary><category term="计算机与 Internet"></category></entry></feed>