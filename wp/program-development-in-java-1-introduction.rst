Program Development in Java 1 Introduction
##########################################
:date: 2007-09-16 05:29
:tags: 计算机与 Internet

1 简介 Introduction
本书将发展出一套构建软件系统的方法。我们的目标是帮助程序员构建高质量程序——可靠，高效，尽量容易理解、修改和维护的程序。
一个很小的不超过几百行代码构建的程序，可以被实现成单独的一个整体单元(monolithic
unit)。然而随着程序增大，这样一个整体的结构不再合理，因为代码变得难以理解。因此，程序必须被分解成大量小块独立程序，叫做模块(module)，它们一起提供需要的功能。我们将专注于这个分解的过程：怎样将大型程序问题分解成小问题，什么样的模块在这一过程中最有用，以及怎样的技术能更好的将模块组合起来解决原始的问题。
随着程序由于种种原因增大，适当地分解工作变得越来越重要。首先，大型程序的构建工作必须涉及许多人。如果只有很少的一部分人在为程序工作，他们很自然的相互频繁沟通。这种交流减少了对彼此正在开发的代码的误解，并且它降低了误解导致的后果的严重性。如果许多人在一个计划上工作，频繁的交流因为太消耗时间而变得不可能。因此，整个程序必须分解成小块，让每个人都可以用最小的沟通独立地工作。
当一个程序被分发到客户时，它的有用时期（作为产品的时期）才开始。然而这时对于程序的工作仍没有结束。代码很可能包含需要注意的残留错误，并且程序经常要求被修改，以提升程序的服务能力，或提供更好地符合客户需求的服务。对程序的修改和维护很可能占用整个工程的大部分。
为了修改和维护，推倒重来重新设计整个程序通常是不现实的。因此，必须在已有的结构上翻新修改，所以结构适应于改变是很重要的。尤其是每部分程序必须相互独立，这样对一部分程序的改变才不至于需要改变程序的每一部分。
最后，大多数程序有很长的服役期。程序员经常需要处理那些他们很久以前编写的程序。并且，实际上很有可能在一个工程的服役期中发生人事调换，这样程序的修改和维护通常是原始实现者之外的人做的。所有这些因素要求程序以容易理解的方式编写。
在我们将在书中描述的方法中，基于有用抽象的认知，程序将以分解问题的方式开发。分解(decomposition)和抽象(abstraction)，这两个书中的关键概念，将是我们的下一个主题。
1.1 分解和抽象 Decomposition and Abstraction
最基本的处理大型问题的原则是明确的——必须“分而治之”。不幸的是，仅仅决定要遵循古训，我们离解决手头的问题还有很长的一段路要走。准确地说，选择怎样分解问题才是最重要的。
分解程序的目标是创造那些自己是小程序的模块，互相之间通过良好定义的简单方式相互耦合。如果达到了这个目标，不同的人可以独立的在不同的模块上工作，互相之间不需要太多交流，并且模块会一起协同工作。另外，在程序的修改和维护过程中，有可能修改一个模块而不影响到其它的模块。
当我们分解问题时，我们用这样的方法把它划分为子问题： n
每一个子问题处在同样的细节层面。 n 每一个子问题可以被独立解决。 n
组合所有子问题的解决方案可以解决原始问题。 排序算法中的归并排序(merge
sort)是分而治之解决问题的典型示例。它把排序一组任意数量的数据的问题分解为排序两组较少的数据，然后将它们归并为原始数量的已排序数据。
分解是一种历史悠久并且有用的技术，在许多领域中发挥着作用。从Babbage[1]时代以来，人们就已经意识到象宏(macro)和子程序(subroutine)这样的分解设施对程序员很有帮助。然而同样重要的是认识到，分解并不是万能的，如果不能正确使用，它有可能造成危害。而且，大型或者没有很好领悟的问题很难适当的分解。最通常的问题是构建了单独的组建解决了描述的子问题，但是不能将他们组合起来解决原始的问题。这也是为什么系统集成通常很难实现。
举个例子，想象让一群作家聚在一起编写剧本，给每个人一份角色名单和情节提纲，然后让他们分别撰写一位角色的台词。作家们可能出色的完成了他们各自的任务，但是他们的成果结合起来不可能成为一个出色的剧本。它很可能完全缺乏一致性或逻辑性。如果原本的任务已经被以一种起反作用的方式分割，那么单独来看可行的方案完全不能适当地组合在一起。
通过改变考虑细节的层面，抽象可以有效地实施分解。当我们从一个问题抽象时，我们可以忽略一些细节，把原始问题转换为一个更简单的问题。举个例子，我们可能将写剧目的问题抽象成它应该有几幕，或者它的情节将是什么，或者是每一段独立的对话的大意（而不是用词）是什么。在这一步骤做完之后，原来的问题（写所有的对话）仍然存在，但它已经被极大地简化了——可能甚至已经可以让别人或者甚至几个人来接手写它了。（Alexandra
Dumas père大仲马就是这样“勾兑”出他的小说的。）
在程序设计过程中抽象以及分解的方法是典型的：分解用来将软件拆散成小的组建，可以将它们组合起来解决原始的问题；抽象则帮助怎样正确地选择组建。我们在这两个过程中切换，直到我们已经把原始问题降低到一系列我们知道如何去解决的问题。
1.2 抽象 Abstraction
一个abstraction的过程可以看作是一个多对一映射的运用。它允许我们忽略掉一些信息，结果是我们可以将不同的东西当作同样的对待。我们这样做是希望，通过把相关的属性和无关的属性区分开来，可以简化我们的分析工作。然而记住这一点很重要，相关性通常由环境决定。在小学的课堂学习环境中我们学会将以及5+3的概念抽象为我们用数字8来表达的概念。在多年之后的学习中，通常是一个讨厌的环境下，我们学到在许多计算机上这样的抽象会把我们卷进一大堆麻烦。
举个例子，考虑在图示1.1中显示的结构。在其中的主要概念是“哺乳动物”。所有的哺乳动物共享一些特点，比如说雌性产奶。在这一层的抽象中，我们关注这些共同的特点，并忽略那些不同种类的哺乳动物间的区别。
在更低的抽象层次中，我们可能尤其关注于哺乳动物实例。然而甚至此时我们也可以不考虑个体或种群，而是一组相关的种群。在这一层次，我们可以按照灵长类和啮齿类来分类。再一次，我们关注于共同的特点，而不是人类和黑猩猩这样的差异。这种差异在更低的一层抽象中起作用。
示例1.1 一个抽象层次
示例1.1中的抽象层次来自于动物学领域，但是它同样可能出现在一个动物学应用的程序中。一个更明确的面向计算机的示例是在很多程序中发挥作用的“文件”的概念。文件是抽象自原始存储(raw
storage)概念，并且提供长期在线存储的命名设施。操作系统对于文件的理解各有不同；举个例子，文件名的结构在每个系统上各不相同，同样文件被存储在后备存储设备上的形式也不相同。
在本书中，我们对抽象感兴趣，是因为它普遍使用在程序中。现代这一领域中最明显的发展是高级语言。通过直接处理高级语言的结构，而不是和（高级语言结构转换成的）机器指令序列打交道，程序员的工作得到了显著地简化。
然而在近几年，程序员变得对高级程序语言通常达到的抽象层次表现出不满。举个例子，考虑示例1.2中的程序片断。在被语言定义的抽象层面，这些片断很明显是不同的：如果在数组a中出现了e，那么第一段记录第一次出现的序号，而第二段记录最后一次出现的序号。如果没有出现e，一个会设置i为a.length，另一个会设置为-1。然而两端代码达成了同一个目标也不是不可能的：如果a中没有出现e，那么将found设为false，否则设为true并且z被设为a中出现的e的序号。如果这正是我们所需要的，这从程序段本身来看并不明显。
示例1.2 两段程序片断 //正向搜索 found=false; for (int i = 0; i
[...]|image0|

.. |image0| image:: http://stats.wordpress.com/b.gif?host=farseerfc.wordpress.com&blog=15617405&post=6&subd=farseerfc&ref=&feed=1
